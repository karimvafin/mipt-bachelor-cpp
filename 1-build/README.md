# Системы сборки в C++

Цель: пройти путь от ручной сборки к Make и CMake, показать ключевые концепции (цели, зависимости, переменные, шаблонные правила, раздельная компиляция, библиотеки, out-of-source сборка) и закрепить все на минимальных примерах.

Система сборки — это набор правил и инструментов, который описывает как из исходников получить бинарники, и обеспечивает повторяемый процесс сборки.

## Введение

- Почему вообще нужна система сборки: рост проекта, повторяемость, скорость.
- Проблемы ручной компиляции: забытые флаги, порядок линковки, полная пересборка (rebuild) всего проекта.
- Ключевые термины:
  - Цель (target) — файл или действие, которое нужно получить (например, `app`).
  - Зависимость (dependency) — то, от чего зависит цель (исходник, объект, библиотека).
  - Правило (rule) — описание, как из зависимостей получить цель.
  - Артефакт — любой выходной файл сборки (`.o`, `.a`, бинарник).

Мини-команда для иллюстрации:

```
g++ -std=c++20 -O2 -Wall -Wextra -pedantic -o hello main.cpp
```

## Порядок компиляции и линковки в C++

Перед автоматизацией важно понять базовые шаги сборки в многофайловом проекте:

- Препроцессинг — этап, где раскрываются `#include` и макросы, формируя единый текст.
- Компиляция — превращение текста `.cpp` в объектный файл `.o`.
- Объектный файл (`.o`) — скомпилированный машинный код без финальной сборки в программу.
- Translation unit — результат препроцессинга одного `.cpp`; компилируется независимо от других.
- Генерация ассемблера — остановка компиляции на шаге `.s`, чтобы увидеть код компилятора.
- Ассемблерный файл (`.s`) — текстовое представление машинных инструкций.
- Линковка — объединение всех `.o` и библиотек в один бинарник.
- Символ — имя функции/переменной, которое ищет линкер при сборке.

Минимальная структура многофайлового проекта:

- `main.cpp` использует функции из `util.cpp`.
- `util.h` содержит объявления (declarations) — описания интерфейса, доступного другим `.cpp`.
- Определение (definition) — реальная реализация функции/класса в `.cpp`.
- Заголовок (`.h`) — файл с объявлениями, подключаемый через `#include`.
- Исходник (`.cpp`) — файл с определениями, который компилируется в `.o`.
- `#include` — директива препроцессора, вставляющая текст заголовка в `.cpp`.

Папка с примером: `1-build/00-manual`

Команды (ручной процесс):

```
cd 1-build/00-manual
g++ -S main.cpp -o main.s
g++ -c main.cpp
g++ -c util.cpp
g++ -o app main.o util.o
./app
```

Чтобы узнать подробнее о каком-нибудь флаге:
```
g++ --help | grep " <flag> "
Пример: g++ --help | grep " -с "
```

Зачем нужны заголовки и почему нельзя обойтись только `.cpp`:

- Заголовок задает интерфейс: объявляет функции/классы, которые нужны другим `.cpp`.
- `#include` буквально вставляет текст заголовка в `.cpp`, делая объявления видимыми компилятору.
- Без заголовков пришлось бы дублировать объявления в каждом `.cpp`, что ведет к ошибкам и рассинхронизации.
- Компиляция идет по translation units: каждый `.cpp` компилируется отдельно и не знает о символах из других файлов без объявлений.

## Make: самый простой проект

Папка: `1-build/00-hello`

Понятия:

- `Make` — утилита, которая исполняет правила из `Makefile`.
- `Makefile` — файл с правилами сборки для `make`.
- Переменные `CXX`, `CXXFLAGS` — именованные параметры, которые можно переиспользовать.
- Автоматические переменные `$@`, `$<` — значения цели и первого источника в текущем правиле.
- Фиктивные цели `run`, `clean` — цели без файлового артефакта.

Команды:

```
cd 1-build/00-hello
make # -- собирает первую цель
make run
make clean
```

## Make: переменные и шаблонные правила

Папка: `1-build/01-make-vars`

Понятия:

- Раздельная компиляция — когда каждый `.cpp` собирается в свой `.o`.
- Список исходников `SRCS` — перечень всех `.cpp`, участвующих в сборке.
- Список объектов `OBJS` — перечень `.o`, соответствующих `SRCS`.
- Шаблонное правило `%.o: %.cpp` — правило для файлов с одинаковыми шаблонами имен, которое говорит: «если нужна %.o, то можно получить её из соответствующего %.cpp».
- Автоматические переменные `$@`, `$<`, `$^` — цель, первый источник и все источники.

Команды:

```
cd 1-build/01-make-vars
make
./calc
make clean
```

Про .PHONY:
Если в папке есть файл с именем clean, то без .PHONY команда make clean решит, что цель уже “собрана” (файл существует) и ничего не сделает.
.PHONY говорит make: “это не файл, а команда”, поэтому правило выполняется всегда, независимо от того, есть файл clean или нет.

## Make: структура каталогов и автогенерация зависимостей

Папка: `1-build/02-make-multi`

#pragma once — это директива препроцессора, которая говорит компилятору подключать этот заголовок только один раз за сборку одного translation unit.

Понятия:

- Отдельные каталоги `src/`, `include/`, `build/`, `bin/` — разделение исходников и артефактов.
- `CPPFLAGS` — флаги препроцессора, в том числе пути `-I` для заголовков.
- Генерация зависимостей `-MMD -MP` — создание файлов `.d` с заголовочными зависимостями.
- Файл `.d` — список зависимостей объекта от заголовков для инкрементальной сборки.
- Инкрементальная сборка — пересборка только того, что изменилось, без полного rebuild.
- `wildcard` — функция Make, возвращающая список файлов по шаблону.
- `patsubst` — функция Make для замены шаблонов в строках/путях.
- @ -- не печатать команду в консоль, просто выполнить

Команды:

```
cd 1-build/02-make-multi
make
make run
make clean
```

## Make: статическая библиотека и линковка

Папка: `1-build/03-make-lib`

Понятия:

- Статическая библиотека (`.a`) — архив объектных файлов, линкуемый в бинарник.
- `ar` — архиватор, который создаёт `.a` из `.o`.
- Линковка библиотеки — добавление ее объектных файлов в итоговый бинарник.
- Разделение на библиотечные и прикладные исходники — вынос переиспользуемого кода.
- rcs — это набор флагов для ar:
r — replace: добавить/заменить файлы в архиве
c — create: создать архив, если его нет
s — create index: создать таблицу символов (для быстрого линкования)

Для чего делать include заголовка в source файл:

1) Чтобы компилятор увидел объявления sub и mul и мог проверить, что определения в .cpp совпадают с объявлением.
2) Чтобы не было рассинхрона: если поменять сигнатуру в calc.h, компилятор сразу поймает несоответствие в calc.cpp.
Это хорошая практика: реализация должна включать свой же заголовок, чтобы гарантировать согласованность интерфейса и реализации.

Команды:

```
cd 1-build/03-make-lib
make
make run
make clean
```

## CMake: базовый проект

Папка: `1-build/04-cmake-basic`

Понятия:

- CMake — генератор сборочных файлов (Makefiles, Ninja, проекты IDE).
- `cmake_minimum_required` — минимальная версия CMake для проекта.
- `project` — объявление проекта и языков.
- `add_executable` — создание цели-исполняемого файла.
- `target_compile_features` — требования к стандарту/фичам C++.
- Out-of-source сборка — сборка в отдельной папке `build`, без мусора в исходниках.

Команды:

```
cd 1-build/04-cmake-basic
cmake -S . -B build
cd build
make
./hello
```

## CMake: цели, библиотеки и зависимости

Папка: `1-build/05-cmake-targets`

Понятия:

- Цель (target) в CMake — логическая единица сборки (библиотека или бинарник).
- `add_library` — создание библиотечной цели.
- `add_executable` — создание исполняемой цели.
- `target_include_directories` — include-пути для цели.
- `PUBLIC/PRIVATE` — область видимости свойств: публичные наследуются потребителями.
- `target_link_libraries` — линковка целей и библиотек.
- Интерфейсные настройки — свойства, которые получают потребители цели.

Примеры `PUBLIC/PRIVATE`:

- `target_include_directories(math PUBLIC include)` — заголовки нужны и самой библиотеке, и всем, кто ее подключает.
- `target_compile_options(math PRIVATE -Wall -Wextra)` — предупреждения применяются только к библиотеке, не к потребителям.
- `target_link_libraries(app PRIVATE math)` — приложение использует библиотеку, но дальше это не наследуется.

Команды:

```
cd 1-build/05-cmake-targets
cmake -S . -B build
cmake --build build
./build/app
```

## Динамические библиотеки

Понятия:

- Динамическая библиотека (shared library) — библиотека, которая подгружается в момент запуска приложения.
- Статическая библиотека (`.a`) — библиотека, которая встраивается в бинарник при линковке.
- Рантайм‑линковщик — часть системы, которая находит и загружает динамические библиотеки при запуске.

Отличия динамических и статических библиотек:

- Динамические библиотеки уменьшают размер бинарника и могут разделяться между разными программами.
- Статические библиотеки дают полностью автономный бинарник, но увеличивают его размер.
- Обновление динамической библиотеки может повлиять на все приложения, которые ее используют.

Примеры часто используемых динамических библиотек:

- `libstdc++` или `libc++` — стандартная библиотека C++.
- `libc` — стандартная библиотека C.
- `libm` — математическая библиотека.

Пример компиляции с динамической библиотекой:

```cpp
// main.cpp
#include <cmath>
#include <iostream>

int main() {
    double x = 2.0;
    std::cout << "sqrt(" << x << ") = " << std::sqrt(x) << std::endl;
    return 0;
}
```

Команды для компиляции:

```bash
# Компиляция и линковка с математической библиотекой libm
g++ -std=c++20 -o app main.cpp -lm

# Запуск программы
./app
```

Примечание: флаг `-lm` указывает линкеру подключить математическую библиотеку `libm`. На большинстве систем стандартные библиотеки C++ (`libstdc++`, `libc++`) подключаются автоматически, но некоторые библиотеки (например, `libm`) требуют явного указания.

Пример создания и использования пользовательской динамической библиотеки:

```cpp
// math_lib.h
#pragma once

int add(int a, int b);
int multiply(int a, int b);
```

```cpp
// math_lib.cpp
#include "math_lib.h"

int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}
```

```cpp
// main.cpp
#include "math_lib.h"
#include <iostream>

int main() {
    std::cout << "add(3, 4) = " << add(3, 4) << std::endl;
    std::cout << "multiply(3, 4) = " << multiply(3, 4) << std::endl;
    return 0;
}
```

Папка: `1-build/07-dyn-lib`

Понятия:

- `SHARED` — тип библиотеки в CMake для динамической сборки.
- `add_library(math SHARED ...)` — создание динамической библиотеки `math`.
- `target_link_libraries(app PRIVATE math)` — линковка приложения с динамической библиотекой.
- `RPATH` — путь поиска динамических библиотек, зашитый в бинарник.
- `@loader_path` (macOS) / `$ORIGIN` (Linux) — специальные переменные для указания директории исполняемого файла в RPATH.

Команды:

```bash
cd 1-build/07-dyn-lib
cmake -S . -B build
cmake --build build
./build/app
```

Примечание: CMake автоматически:
- Добавляет флаг `-fPIC` при компиляции объектов для динамической библиотеки.
- Создает библиотеку с правильным расширением (`.so` на Linux, `.dylib` на macOS).
- Настраивает RPATH для поиска библиотеки в директории исполняемого файла, что позволяет запускать программу без указания `LD_LIBRARY_PATH` или `DYLD_LIBRARY_PATH`.

Ручная компиляция с динамической библиотекой:

```bash
cd 1-build/07-dyn-lib

# 1. Компиляция библиотеки в объектный файл с флагом -fPIC (Position Independent Code)
g++ -std=c++20 -fPIC -c math_lib.cpp -o math_lib.o

# 2. Создание динамической библиотеки
# На Linux: создается libmath.so
g++ -shared -o libmath.so math_lib.o
# На macOS: создается libmath.dylib
g++ -shared -o libmath.dylib math_lib.o

# 3. Компиляция программы с линковкой к динамической библиотеке
# -L. указывает линкеру искать библиотеки в текущей директории
# -lmath подключает библиотеку libmath.so (или libmath.dylib)
g++ -std=c++20 -o app main.cpp -L. -lmath

# 4. Запуск программы
# На Linux может потребоваться указать путь к библиотеке:
LD_LIBRARY_PATH=. ./app
# На macOS:
DYLD_LIBRARY_PATH=. ./app
```

Объяснение флагов:

- `-fPIC` (Position Independent Code) — генерирует позиционно-независимый код, необходимый для динамических библиотек. Это означает, что код может быть загружен и выполнен по любому адресу в памяти, а не только по фиксированному. Это требуется потому, что динамическая библиотека может быть загружена в разные адресные пространства разных процессов, и её адрес в памяти заранее неизвестен. Без `-fPIC` динамическая библиотека не сможет корректно работать при загрузке в память.
- `-shared` — создает динамическую библиотеку вместо исполняемого файла.
- `-L.` — указывает линкеру искать библиотеки в текущей директории.
- `-lmath` — подключает библиотеку `libmath.so` (или `libmath.dylib`). Линкер автоматически добавляет префикс `lib` и расширение.
- `LD_LIBRARY_PATH` / `DYLD_LIBRARY_PATH` — переменные окружения для указания путей поиска динамических библиотек во время выполнения.

## CMake: динамическая библиотека

Папка: `1-build/06-cmake-shared`

Понятия:

- `SHARED` — тип библиотеки в CMake для динамической сборки.
- `RPATH` — путь поиска динамических библиотек, зашитый в бинарник.

Команды:

```
cd 1-build/06-cmake-shared
cmake -S . -B build
cmake --build build
./build/app
```

Примечание: если система не находит библиотеку при запуске, можно временно указать путь через переменные окружения `LD_LIBRARY_PATH` (Linux) или `DYLD_LIBRARY_PATH` (macOS).

## Сравнение Make и CMake

- Make — это исполнитель правил, CMake — генератор (создает Makefiles, Ninja, проекты IDE).
- Ninja — быстрый инструмент сборки, альтернативный Make.
- IDE (среда разработки) — инструменты для написания, сборки и отладки кода.
- Make проще и ближе к "железу", но сложнее масштабировать.
- CMake добавляет абстракции: цели, свойства, зависимости, генерация сборочных файлов.

## Практика

Идеи для самостоятельной работы:

- Добавить новый исходник и проверить, что rebuild корректен.
- Для Make: добавить флаг `-g` в `CXXFLAGS` и сравнить размер бинарника.
- Для CMake: сделать библиотеку `INTERFACE` и попробовать заменить статическую.
- `INTERFACE` библиотека — цель без собственных исходников, которая передает настройки потребителям.
